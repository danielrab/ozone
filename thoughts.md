- ranges are good, let's have those, a number should be defined by which values it can have, not by some amount of bits.
- union types are great as long as they are tagged.
- unsafe sucks, let's instead have prerequesites, at least when possible
- knowing what your function does is great, so an effects system.
- prefix operators suck.
- operators generally don't give you any hints for whay they are doing, lets have as little as possible built-in operators and allow people to instead declare operators on a per-scope/file basis, so you can always see the definition of the operator easily.
- language features should be as deconstructable as possible, if something is syntax sugar, you should be able to see the defenition that expands it.
- proper syntax for things is more than just a nice thing to have, being able to look at the "shape" of the code and get immediate understanding of what approximately going on is valuable.
- good error messages and intellisence are as much of a language feature as the type system.
- to achieve the previous three points together, there's a need for a way to define language features in a structured way. Rust's declarative macros are alright, but both have noise because of the required scope, and more importantly they give you errors at expansion from the expanded body. A more proper way would have ways to both declare what are the requirements of the macro (for example, `if` is followed by a boolean expression, and then by a scope), and to check that if those conditions are satisfied the expansion will succeed.
- types are basically sets and can have any relationships sets can.
- the core parts of the language should be general, and have a single specific meaning regardless of context.
- traits are great, especially if you extend them to state arbitrary properties about types in a provable way.
- panicking is bad, should never be implicit part of language features, and should be a side-effect you can require the abscence of on a function.